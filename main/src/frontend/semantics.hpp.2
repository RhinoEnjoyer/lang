// #pragma once

// #include "parser.hpp"
// #include <cstddef>
// #include <cstdint>
// #include <functional>
// #include <string_view>
// #include <unordered_map>
// #include <variant>

// namespace semantics {

// enum integral_type_e { UINT, SINTEGER, FLOAT};
// struct integral_type_t {
// public:
//   size_t size() const { return size_; }
//   integral_type_e type() const { return type_; }
//   bool is_signed() const { return type_ != UINT; }
//   bool is_int() const { return type_ == UINT || type_ == SINTEGER; }
//   bool is_real() const { return type_ == FLOAT; }

//   constexpr integral_type_t(const size_t size, const integral_type_e type)
//       : size_(size), type_(type) {}

//   bool operator==(const integral_type_t &other) const {
//     return this->size_ == other.size_ && this->type_ == other.type_;
//   }

// private:
//   size_t size_;
//   integral_type_e type_;
// };

// size_t integral_bit_size(const std::string_view &view) {
//   std::string_view number_view = view.substr(1);
//   char *end = nullptr;
//   size_t value = std::strtol(number_view.data(), &end, 10);

//   if (end != number_view.data() + number_view.size()) {
//     // error bad input
//     std::abort();
//   } else if (value == 0) {
//     // error can't have a zero size integral
//     std::abort();
//   }

//   return value;
// }

// [[nodiscard]] auto
// integer_integral(const std::string_view view) -> integral_type_t {
//   const auto val = integral_bit_size(view);
//   return integral_type_t{val, (view[0] == 's') ? SINTEGER : UINT};
// }

// [[nodiscard]] auto float_integral(std::string_view view) -> integral_type_t {
//   const auto val = integral_bit_size(view);
//   switch (val) {
//   case 32:
//   case 64:
//     return integral_type_t{val, FLOAT};
//   default:
//     // error unsupported size
//     std::abort();
//   }
// }

// using cursor_t = std::span<parser::node_t>::const_iterator;

// struct named_t {
//   std::string_view name;
// };

// template<typename Key, typename Val>
// using map = std::map<Key, Val>;

// template<typename ...T>
// using var = std::variant<T...>;

// template<typename T>
// using opt = std::optional<T>;

// struct decl_t {
//   struct vardecl_t: named_t {
//     size_t type_index;
//     opt<size_t> val_index;
//   };

//   struct typedecl_t: named_t {
//     size_t type_index;
//   };

//   struct scopedecl_t : named_t {
//     using elm_t = var<vardecl_t, typedecl_t, scopedecl_t>;
//     scopedecl_t *parent;
//     map<std::string_view, decl_t> symbols;

//     auto lookup(const std::string_view name) ->
//     opt<std::reference_wrapper<decl_t>> {
//       auto it = symbols.find(name);

//       if (it != symbols.end()) [[likely]]
//         return it->second;

//       if (parent) [[likely]]
//         return parent->lookup(name);

//       return std::nullopt;
//     }

//     auto insert(const std::string_view name,
//                 decl_t val) -> opt<std::reference_wrapper<decl_t>> {
//       auto [it, inserted] = symbols.emplace(name, val);
//       if (!inserted)
//         return std::nullopt;
//       return std::ref(it->second);
//     }

//     // template <typename... T> auto lookup(T... chain) ->
//     opt<std::reference_wrapper<decl_t>> {}
//   };
// };

// template<typename T>
// using sptr = std::shared_ptr<T>;

// struct stmt_t {};
// using intlit_t = std::int64_t;
// using uintlit_t = std::uint64_t;
// using floatlit_t = std::double_t;
// using numlit_t = std::variant<intlit_t, uintlit_t, floatlit_t>;
// using strlit_t = std::string_view;

// struct symbol_t {
//   std::string_view name;
// };

// struct expr_t{};

// struct ast_t {
//   std::variant<symbol_t, expr_t>
// };

// struct locale_t {
//   sptr<locale_t> parent;
//   std::unordered_map<std::string_view, sptr<symbol_t>> lookup_table;
//   std::vector<sptr<symbol_t>> symbols;
// };

// struct type_t {};

// enum instr_e { ZERO, CREATE, ASIGN, ADD, PLUS, MINUS, DIV, MUL };
// struct instr_t {
//   instr_e code;
//   std::vector<symbol_t> args;
// };

// struct complit_t {
//   type_t type;
//   std::vector<expr_t> elms;
// };

// using lit_t = std::variant<numlit_t, strlit_t, complit_t>;

// struct ctx_t {
//   const token_buffer_t &toks;
//   const podlist_t<parser::node_t> &nodes;

//   podlist_t<instr_t> instr;

//   // scope managment
//   auto emerge() -> auto {}
//   auto dive(const std::string_view name) -> auto {}
//   auto push(const symbol_t symbol) -> void {}

//   template <typename OUT>
//   auto lookup(std::string_view needle) -> opt<OUT> {}
// };

// #define FN_ARGS_DECL ctx_t &ctx, cursor_t &cursor
// #define FN_ARGS ctx, cursor
// #define FN_RET void
// #define FN_SIGN (FN_ARGS_DECL) -> FN_RET

// auto type_fn FN_SIGN {
//   cursor++;
//   if (cursor->is_final()) {
//     auto f = cursor->as_final();
//     switch (f->base()->type_) {
//     case tokc::TYPE_FLOAT:
//       // float_integral(ctx.toks.str(f.get()));
//       break;
//     case tokc::TYPE_UINT:
//     case tokc::TYPE_INT:
//       // integer_integral(ctx.toks.str(f.get()));
//       break;
//     }
//   } else if (cursor->is_median()) {
//     auto m = cursor->as_median();
//     switch(m->type_){
//       case medianc::CHAIN:
//         break;
//       case medianc::FN_SIG:
//         break;
//     }
//     // unsuported
//     std::abort();
//   }
// }

// auto decl_fn FN_SIGN {
//   cursor++;
//   auto n = cursor->as_final();

//   cursor++;
//   auto t = cursor->as_median();

//   cursor += t.children().size();
//   auto v = [&] -> opt<parser::node_t::median_proxy_t<true>> {
//     if (cursor->is_median() && cursor->as_median()->type_ == medianc::VALUE)
//       return cursor->as_median();
//     return std::nullopt;
//   }();
//   assert(v.has_value() == false);

//   //query for n so we know that it is available in the local scope

//   //check what t is
//   // it might be a function , record, union, enum
//   // if it is one of those we do not need to query a id
//   //   (maybe) create a id for that type and point to that type
//   //   have the ids to be made with a deterministic way
//   //   the names of the types need to be desugared
//   // else query for t
//   //   get what it is
//   // if it is a type continiue

//   // check the result of the value if it exists
//   // query the ids there

// }

// auto stmt_fn FN_SIGN {
//   cursor++;
//   switch (cursor->as_median()->type_) {
//   default:
//     std::cerr << "Not supported" << std::endl;
//     std::abort();
//     break;
//   case medianc::DECL: // name -> query and entry, type -> entry or query,
//   value -> query and entry
//     break;
//   case medianc::TYPE_DECL: // name -> query and entry, type -> entry or
//   query, value -> query and entry
//     break;
//   case medianc::SCOPE_DECL:
//     break;
//   case medianc::IMPORT:
//     break;
//   case medianc::EXPR:
//     break;
//   case medianc::FOR:
//     break;
//   }
// }

// auto entry(token_buffer_t &toks,
//            podlist_t<parser::node_t> &file_nodes) -> auto {
//   auto nodes = file_nodes.front().as_median().children();
//   auto cursor = nodes.cbegin();
//   auto end = nodes.cend();

//   ctx_t ctx = {toks, file_nodes};

//   while (cursor <= end) {
//     switch (cursor->as_median()->type_) {
//     default:
//       std::cerr << "Not supported" << std::endl;
//       std::abort();
//       break;
//     case medianc::STMT:
//       stmt_fn(ctx, cursor);
//       break;
//     }
//     cursor++;
//   }

//   return 0;
// }

// #undef FN_ARGS_DECL
// #undef FN_ARGS
// #undef FN_RET
// #undef FN_SIG

// } // namespace semantics

#include "parser.hpp"
#include <memory>
#include <string_view>
#include <unordered_map>

namespace semantics {

template <typename T> using opt = std::optional<T>;
template <typename T> using sptr = std::shared_ptr<T>;

struct parser_it_t {
  podlist_t<parser::node_t>::c_it node;
};

struct locale_t;
struct scopedecl_t : parser_it_t {
  sptr<semantics::locale_t> symbols;
};
struct vardecl_t : parser_it_t {};
struct typedecl_t : parser_it_t {};

struct locale_t {
  sptr<locale_t> parent;
  using var = std::variant<scopedecl_t, vardecl_t, typedecl_t>;
  using lookup_t = opt<std::reference_wrapper<var>>;
  std::unordered_map<std::string_view, var> table;

  auto insert(std::string_view name, locale_t::var val) -> auto {
    return this->table.try_emplace(name, std::move(val)).second;
  }

  auto lookup(const std::string_view name) -> lookup_t {
    auto it = table.find(name);

    if (it != table.end())
      return it->second;

    if (parent) [[likely]]
      return parent->lookup(name);

    return std::nullopt;
  }
};

struct locale_state_t{ 
  sptr<semantics::locale_t> global;
  sptr<semantics::locale_t> local;

  static auto make() -> locale_state_t {
    auto g = std::make_shared<semantics::locale_t>(locale_t{nullptr, {}});
    return {g, g};
  }

  auto emerge() -> bool {
    if (local->parent) {
      local = local->parent;
      return true;
    }
    return false;
  }

  auto insert(std::string_view name, locale_t::var val) -> auto {
    return local->insert(name, std::move(val));
  }

  auto dive(parser_it_t node, std::string_view name) -> auto {
    auto new_scope = std::make_shared<locale_t>(locale_t{local, {}});
    auto inserted = insert(name, scopedecl_t{node, new_scope});

    if(!inserted)
      return false;

    local = new_scope;
    return true;
  }
};

} // namespace semantics
